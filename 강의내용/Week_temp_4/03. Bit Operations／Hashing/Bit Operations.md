# Bit Operations (비트 연산)

## **Bit**

가장 작은 데이터 단위  
2진수로 표현 가능한 0과 1로만 이루어져 있다  

## **2진수의 특징**

2진수의 각 자리(n)의 수는  
2^n 만큼의 값을 가지고 있다  

## 1의 보수의 연산

2진수 모든 자리의 수를 0을 1으로 / 1을 0으로 교환한다

4byte에서 가장 앞자리 비트는 부호 비트로 사용한다  

11111111을 -0으로 

## 2의 보수

1의 보수에서 -0 + -0을 했을 경우 0이 나오지 않는 경우를 해결하기 위해
1의 보수에 1을 더한 값을 2의 보수라고 한다

## **비트연산자**

### A `&` B

- AND
- A 와 B가 모두 1이면 1 아니면 0
``` C++
int A = 3;			// 0011
int B = 5;			// 0101

int C = A & B;
cout << C << '\n';	// 0001
```

### A `|` B

- OR
- A와 B중 하나만 1이여도 1 아니면 0
``` C++
int A = 3;			// 0011
int B = 5;			// 0101

int D = A | B;
cout << D << '\n';	// 0111
```

### A `^` B

- XOR
- 둘이 다르면 1 아니면 0
- 특징
  - `A ^ N ^ N = A`
  - 같은 수를 XOR 연산을 취하면 0
  - 암호화에 주로 사용됨
``` C++
int A = 3;			// 0011
int B = 5;			// 0101

int E = A ^ B;
cout << E << '\n';	// 0110
```

### `~` A

- NOT, *Complemet (보수 연산)
- 0이면 1, 1이면 0
``` C++
int A = 3;			// 0011
int B = 5;			// 0101

int F = ~A;
cout << F << '\n';	// 1100
```

### `>>` N

- Right Shift
- 모든 비트를 N칸 오른쪽으로 이동
- 쉬프트 연산시 앞에 들어오는 0 또는 1은 부호를 따라 들어온다.
  - 음수일 경우
    - 1
  - 양수일 경우
    - 0
``` C++
int A = 3;			// 0011
int B = 5;			// 0101

int G = A >> 1;
cout << G << '\n';	// 0001
```

### `<<` N

- Left Shift
- 모든 비트를 N칸 왼쪽으로 이동
``` C++
int A = 3;			// 0011
int B = 5;			// 0101

int H = A << 1;
cout << H << '\n';	// 0110
```

## 비트 연산을 사용하는 경우

1. 문제가 비트연산을 요구하는 경우
2. 비트마스킹 (bit masking)

### Bitmasking

- 특정비트를 바꾸는 방법
- 